/*
    This file is part of rooter.

    Rooter is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Rooter is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Rooter.  If not, see <http://www.gnu.org/licenses/>
*/

/*
    Requires glibc 2.1.95 or later
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdbool.h>
#include <string.h>
#include <signal.h>
#include <linux/limits.h>
#include <stdio_ext.h> /* For __fpurge */
#include <sys/mount.h>
#include <unistd.h>
#include <errno.h>
#include "console.h"
#include "autorevision.h"

#define MAX_USERNAME_LEN    64
#define MAX_DEV_NAME_LEN    32
#define MAX_OUTPUT_LEN      1024
#define TMPFILE				"cmd.tmp"
#define SUDOERS_BACKUP_FILE	"sudoers.bak"
#define SUDOERS_TEMP_FILE	"sudoers.new"
#define SUDOERS_FILE		"sudoers"
#define script_filename		"root.sh"
#define USERNAME_OPTION		"-u"

#define len(x)				strlen(x)			

#ifdef DEBUG
    static const int debug = 1;
#else
    static const int debug = 0;
#endif

struct menu
{
	int dev_id;
	char device_path[MAX_DEV_NAME_LEN];
};

void show_usage()
{
	const char usage_str[] = "%s %s build %d - (C) 2017-2018 Lucas Vieira de Jesus\nhttps://github.com/lucas-engen/rooter\nBuild date: %s\n\nusage: %s [options]\n\nCommon options:\n\t-u <username> : Name of the user to escalate privileges\n\nExample: %s -u admin\n\n";
	
	fprintf(stdout, usage_str, VCS_BASENAME, VCS_TAG, VCS_NUM, VCS_DATE, VCS_BASENAME, VCS_BASENAME); 
}

void drop_script()
{
	const char *script_body = "#!/bin/sh\n# Script generated by rooter. Do not hand hack!\n\nr=\"$(sudo -s)\"\nif [ \"$?\"=\"0\" ]; then\n\techo OK\nelse\n\techo ERROR\n";
	
	char script[PATH_MAX*2];
	FILE *shell_script = NULL;
	
	shell_script = fopen(script_filename, "w");
	if(shell_script == NULL) {
		rooter_printf(ERROR, "Failed to drop script file: %s\n", strerror(errno));
		return;
	}
	
	snprintf(script, PATH_MAX*2 / sizeof(char), script_body);
	fprintf(shell_script, "%s", script);
	fclose(shell_script);
}

bool isRootLine(char *line_data)
{
	char *p = NULL;
	
	if(line_data == NULL)
		return false;

	if(!(line_data[0] == 'r' && line_data[1] == 'o' && line_data[2] == 'o' && line_data[3] == 't'))
		return false;

	p = strstr(line_data, "root");
	if(p == NULL)
		return false;

	p = strstr(line_data, "ALL=(ALL:ALL)");
	
	return(p != NULL);
}	

int main(int argc, char *argv[])
{
    char username[MAX_USERNAME_LEN];
    __id_t uid;
    FILE *file_pointer = NULL;
    char output_data[MAX_OUTPUT_LEN] = {0};
	int id = 0;
	struct menu m[128];
	int selected_id;
	char id_buff[4];
	int mount_result;
    char working_dir[PATH_MAX] = {0};
    char last_dir[PATH_MAX] = {0};
    const char *temp_folder = "root_temp_folder";
    char buff[PATH_MAX]={0}; /* For generic usage */
    char sudoers_path[PATH_MAX] = {0};
    char new_sudoers_path[PATH_MAX] = {0};
	char shell_cmd[PATH_MAX] = {0};	/* Used to store shell commands */
	int i = 0;
	bool bOption = false;
	
	/* Check if we are root */
    uid = getuid();
    if(uid != 0 && !debug)
    {
        rooter_printf(ERROR, "Sorry. We need root privileges :(\nDon't forget to run this program from a live usb OS\n\n");
        return 1;
    }

	/* Check for command line arguments */
	if(argc != 3)
	{
		show_usage();
		return 1;
	}
	
	for(int i = 1; i < argc; i++) 
	{
		if(strncmp(argv[i], USERNAME_OPTION, len(USERNAME_OPTION)) == 0) 
		{			
			snprintf(username, MAX_USERNAME_LEN / sizeof(char), "%s", argv[i+1]);
			bOption = true;
			break;
		} else {
			rooter_printf(ERROR, "Invalid option => %s\n", argv[i]);
			return 1;
		}
	}
	
	if(!bOption) {
		rooter_printf(ERROR, "I need to know the username\n\n");
		return 1;
	}
	
	rooter_printf(LOG, "Username: %s\n", username);

    if(debug)
        rooter_printf(INFO, "Running in debug mode ...\n");

    /* Check if temporary folder exists */
    if(access(temp_folder,00) != -1)
    {
        snprintf(shell_cmd, PATH_MAX, "umount %s && rmdir %s", temp_folder, temp_folder);
        system(shell_cmd);
    }
		
	/* Remove the '\n' character from username string, if it exists */
	while(username[i]) 
	{
		if(username[i] == '\n')
		{
			username[i] = '\0';
			break;	
		}

		i++;
	}
	
    rooter_printf(PROMPT, "Tell me the name of the device where linux is installed.\nSelect one of the list below:\n");
	
	/* Build command line */
	snprintf(shell_cmd, PATH_MAX, "ls /dev | grep sd > %s", TMPFILE);
    system(shell_cmd);

    file_pointer = fopen(TMPFILE, "r");
    if(file_pointer == NULL)
    {
        rooter_printf(ERROR, "Failed to get devices installed in this machine ...\n");
        return 1;
    }

    sleep(1);

	while(fgets(output_data, MAX_OUTPUT_LEN, file_pointer) != NULL)
    {
    	rooter_printf(INFO, "Device %02d is /dev/%s", id, output_data);
    	snprintf(m[id].device_path, MAX_DEV_NAME_LEN, "/dev/%s", output_data);
    	m[id].dev_id = id;
    	id++;
    }

    fclose(file_pointer);
    remove(TMPFILE);

    jump_line(stdout);
	rooter_printf(PROMPT, "Select one (default is 1): ");
	selected_id = getchar();
	snprintf(id_buff, (sizeof(id_buff) / sizeof(id_buff[0])), "%c", selected_id);
	selected_id = (int)strtol(id_buff, NULL, 10); // WARNING: We are inserting a long to an int
	rooter_printf(INFO, "You have selected %d which is %s", selected_id, m[selected_id].device_path);
    rooter_printf(INFO, "Trying to give root access to %s\n", username);

	if(access(temp_folder, 00) == -1)
	{
        rooter_printf(INFO, "Creating temporary directory ...\n");
        snprintf(shell_cmd, sizeof(shell_cmd), "mkdir %s", temp_folder);
        system(shell_cmd);
        sleep(1);

        if(access(temp_folder, 00) == -1)
        {
            perror( "Failed to create directory");
            return 1;
        }
	}

	/* Remove '\n' character from the end of vector */
	char device[PATH_MAX] = {0};
	int len = strlen(m[selected_id].device_path);

	for(int i = 0; i < len; i++)
	{
		if(m[selected_id].device_path[i] == '\n')
		{
			device[i] = '\0';
			break;
		}

		device[i] = m[selected_id].device_path[i];
	}

	/* Mount filesystem */
	mount_result = mount(device, temp_folder, NULL, 0, NULL);
	if(mount_result == -1)
	{
		snprintf(shell_cmd, PATH_MAX, "mount %s %s", device, temp_folder);
		if(debug)
		{
			rooter_printf(LOG, "Running: %s\n", shell_cmd);
		}

		system(shell_cmd);
		snprintf(shell_cmd, PATH_MAX, "%s/etc", temp_folder);
		if(access(shell_cmd, 00) != -1)
			mount_result = 0;

        __fpurge(stdin); /* Required to call getchar(). Otherwise, getchar will be ignored */

		if(mount_result == -1)
		{
			rooter_printf(PROMPT, "Run shell and type this command: mount %s %s\n", device,temp_folder);
            rooter_printf(PROMPT, "Press enter when you finish.");
            getchar();

			snprintf(buff, PATH_MAX, "%s/etc/%s", temp_folder, SUDOERS_FILE);
			if(debug)
				fprintf(stdout, "Checking if %s exists.\n", buff);

			if(access(buff, 00) == -1)
			{
				fprintf(stdout, "Mount failed again. :(\n");
				snprintf(shell_cmd, PATH_MAX, "rmdir %s", temp_folder);
				system(shell_cmd);
			} else {
				mount_result = 0;
			}
		}
	}

	if(mount_result == -1)
	{
		rooter_printf(ERROR, "Failed to mount: %s\n", strerror(errno));
	} else
    {
        rooter_printf(INFO, "Mounted %s\n", device);
        if(getcwd(last_dir, sizeof(last_dir)) == NULL) /* Saving the path of the last folder ... */
        {
            rooter_printf(ERROR, "Failed to get working directory: %s\n", strerror(errno));
            return 1;
        }

        if(debug)
        {
            if(NULL != getcwd(working_dir, sizeof(working_dir)))
                fprintf(stdout, "(%d): Current directory: %s\n", __LINE__, working_dir);

            fprintf(stdout, "(%d): Last directory: %s\n", __LINE__, last_dir);
        }

        rooter_printf(INFO, "Trying to give root ...\n");

        /* Build sudoers file path */
        snprintf(sudoers_path, PATH_MAX, "%s/etc/%s", temp_folder, SUDOERS_FILE);
        snprintf(new_sudoers_path, PATH_MAX, "%s/etc/%s", temp_folder, SUDOERS_TEMP_FILE);

        if(access(sudoers_path,00) == -1)
        {
            rooter_printf(ERROR, "The file %s does not exists.\n", sudoers_path);
            return 1;
        }

        FILE *sudoers = NULL;
        FILE *new_sudoers = NULL;
        FILE *backup_file = NULL;

        char line[PATH_MAX];
        bool bRoot = false;
		char backup_file_path[PATH_MAX];

		memset(line,0,PATH_MAX);
		memset(backup_file_path,0,PATH_MAX);

        sudoers = fopen(sudoers_path, "r");
        if(sudoers == NULL)
        {
            perror( "Failed to open file for read");
            return 1;
        }

        new_sudoers = fopen(new_sudoers_path, "w");
        if(new_sudoers == NULL)
        {
            perror( "Failed to open file for write");
            return 1;
        }

		snprintf(backup_file_path, PATH_MAX, "%s/etc/%s", temp_folder, SUDOERS_BACKUP_FILE);
		rooter_printf(INFO, "Creating backup file: %s\n", backup_file_path);

		backup_file = fopen(backup_file_path, "w");
        if(backup_file == NULL)
        {
            rooter_printf(ERROR, "Failed to create backup file\n");
			if(new_sudoers)
				fclose(new_sudoers);
			if(sudoers)
				fclose(sudoers);

			return 1;
        }

		rooter_printf(INFO, "Parsing data...\n");
        while(fgets(line, PATH_MAX, sudoers) != NULL)
        {
            fprintf(backup_file, "%s", line);
	
			if(isRootLine(line))
			{
				rooter_printf(OK, "Adding user %s to root ...\n", username);
                fprintf(new_sudoers, "%s ALL=(ALL) ALL\n", username);
                bRoot = true;
			}
            fprintf(new_sudoers, "%s", line);
        }

		rooter_printf(LOG, "Closing files ...\n");
		if(new_sudoers)
        	fclose(new_sudoers);
        if(sudoers)
			fclose(sudoers);

		if(backup_file)
			fclose(backup_file);

        sleep(1);
		
		snprintf(shell_cmd, PATH_MAX, "mv %s %s && rm -f -vv %s", new_sudoers_path, sudoers_path, new_sudoers_path);
		rooter_printf(INFO, "Running command: %s\n", shell_cmd);
        int result = system(shell_cmd);
		rooter_printf(INFO, "Command result: %s\n", strerror(result));
		
        if(bRoot) {
            rooter_printf(OK, "It's all done. Reboot into your native Linux, open shell and type: './%s'. Give your password, and you'll be root. :)\n", script_filename);
			rooter_printf(INFO, "Use the file %s that i have created here\n", script_filename);	
			rooter_printf(INFO, "Don't forget to run 'chmod +x %s' on target OS if you receive 'Access denied' message when trying to run %s\n",script_filename,
script_filename);
			jump_line(stdout);
			drop_script();
		}
        else {
            rooter_printf(ERROR, "Failed to get root. I'm sorry :(\n");
			jump_line(stdout);
		}
    }

    return 0;
}
